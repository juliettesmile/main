# Алгоритмы балансировки нагрузки

Алгоритм балансировки нагрузки – это набор правил, которым следует балансировщик нагрузки для определения наилучшего сервера для каждого из различных клиентских запросов.

## Round robin (циклический перебор)

**Round Robin**, или алгоритм кругового обслуживания, представляет собой перебор по круговому циклу: первый запрос передаётся одному серверу, затем следующий запрос передаётся другому и так до достижения последнего сервера, а затем всё начинается сначала.

*Плюсы*
- Независимость от протокола высокого уровня. Для работы по алгоритму Round Robin используется любой протокол, в котором обращение к серверу идёт по имени.
- Балансировка на основе алгоритма Round Robin никак не зависит от нагрузки на сервер: кэширующие DNS-серверы помогут справиться с любым наплывом клиентов.
- Использование алгоритма Round Robin не требует связи между серверами, поэтому он может использоваться как для локальной, так и для глобальной балансировки.
- Решения на базе алгоритма Round Robin отличаются низкой стоимостью: чтобы они начали работать, достаточно просто добавить несколько записей в DNS.

*Минусы*
- Чтобы распределение нагрузки по этому алгоритму отвечало упомянутым выше критериями справедливости и эффективности, нужно, чтобы у каждого сервера был в наличии одинаковый набор ресурсов. При выполнении всех операций также должно быть задействовано одинаковое количество ресурсов. В реальной практике эти условия в большинстве случаев оказываются невыполнимыми.
- При балансировке по алгоритму Round Robin совершенно не учитывается загруженность того или иного сервера в составе кластера. Если один сервер загружен на 100%, а другие на 10-15%, то запросы на загруженный сервер продолжат поступать в порядке очереди.
- Не учитывается количество активных на данный момент подключений

## Weighted Round Robin
Это — усовершенствованная версия алгоритма Round Robin. Суть усовершенствований заключается в следующем: каждому серверу присваивается весовой коэффициент в соответствии с его производительностью и мощностью. Обладая в общем теми же достоинствами и недостатками что и Round Robin, WRR всё-таки устраняет проблему с распределением нагрузки, распределяя её более гибко: серверы с большим весом обрабатывают больше запросов. Однако всех проблем с отказоустойчивостью это отнюдь не решает. Более эффективную балансировку обеспечивают другие методы, в которых при планировании и распределении нагрузки учитывается большее количество параметров.

## Least Connections (наименьшее количество подключений)

**Least connections (сокращённо — leastconn)** учитывает количество подключений, поддерживаемых серверами в текущий момент времени. Каждый следующий вопрос передаётся серверу с наименьшим количеством активных подключений. Least Connections — это изящное и эффективное решение, которое позволяет адекватно распределять нагрузку по серверам с приблизительно одинаковыми параметрами.

*Плюсы leastconn:* алгоритм учитывает технические характеристики и производительность каждого подключенного сервера. 

*Минусы leastconn:* пожалуй только более высокие накладные расходы на ресурсы балансировщика.

## Least Responce Time (наименьшее время отклика)

Является как бы более чувствительным вариантом Least Connections. Балансировка нагрузки с наименьшим временем отклика распределяет запросы на сервер с наименьшим количеством активных подключений и с самым быстрым средним временем отклика на запрос мониторинга работоспособности. Скорость отклика показывает, насколько загружен сервер.

*Плюсы*
- Метод особенно подходит, когда у вышестоящих серверов очень разное среднее время отклика
- Нагрузка стабильна и предсказуема
- Учитывается недавняя история производительности сервера

*Минус*
- Его производительность зависит от того, насколько хороши оценки времени отклика
- Алгоритм балансировщика нагрузки с наименьшим временем отклика сложен и требует дополнительной обработки

## PEWMA «Peak Exponentially Weighted Moving Average»

PEWMA является комбинацией алгоритмов dynamic weighted round robin и least connections, а значит, впитал и их преимущества и недостатки. Для каждого сервера алгоритм отслеживает задержку последних N запросов. Вместо того, чтобы использовать её как среднее, он суммирует значения, но экспоненциально снижает коэффициент масштаба. Это приводит к тому, что чем старее задержка, тем меньше она влияет на сумму, таким образом недавние запросы влияют на расчёт сильнее, чем старые. Затем это значение умножается на количество открытых соединений с сервером, и результатом этого становится значение, которое мы используем для выбора сервера, которому будем отправлять следующий запрос. Чем меньше значение, тем лучше.

*Плюсы*
- Так как метод пытается добиться наилучшей задержки, он иногда может обеспечивать неполную загрузку сервера вплоть до полного игнорирования самых медленных из них

*Минусы*
- Высокая сложность

## Sticky Sessions

**Sticky Sessions** — алгоритм распределения входящих запросов, при котором соединения передаются на один и тот же сервер группы. Он используется, например, в веб-сервере Nginx. Сессии пользователя могут быть закреплены за конкретным сервером с помощью метода IP hash. С помощью этого метода запросы распределяются по серверам на основе IP-aдреса клиента. Как указано в документации, «метод гарантирует, что запросы одного и того же клиента будет передаваться на один и тот же сервер». Если закреплённый за конкретным адресом сервер недоступен, запрос будет перенаправлен на другой сервер.

*Плюсы*
- Это легко - никаких изменений приложения не требуется.
- Лучше использует локальные кэши RAM (например, один раз посмотрите Профиль пользователя, кэшируйте его и можете повторно использовать его при последующих посещениях от того же пользователя)

*Минусы*
- Если клиент использует динамический IP, могут возникнуть проблемы с привязкой сессий
- Если сервер отключается, сеанс теряется

## HASH (хэш)

Алгоритм хеширования определяет, куда распределять запросы, на основе назначенного ключа, такого как IP-адрес клиента, номер порта или URL-адрес запроса. Алгоритм хэширования равномерно делит набор всех возможных значений хеш-функции на «сегменты», по одному на сервер, но нет никакого способа предсказать, будут ли фактически выполняемые запросы иметь хэши, которые будут равномерно распределены. Метод Hash узконаправлен, что является одновременно его плюсом и минусом, и используется для приложений, которые полагаются на сохраненную информацию о пользователях, например, тележки на веб-сайтах интернет магазинов.

*Плюсы*
- Простой способ сохранение и поддержки сеансов
- Сеанс можно сохранять, даже если приложение браузера или клиента не принимает файлы cookie, и приложение не может работать с механизмами сохранения сеанса без файлов cookie

*Минусы*
- Алгоритм не гарантирует справедливого распределения
- Метод не работает, когда запросы от большого количества клиентов проходят через прямой прокси, потому что IP-адрес прокси используется для всех из них
- А так же когда IP-адрес клиента может измениться во время сеанса, например, когда мобильный клиент переключается из сети Wi-Fi в сотовую сеть
