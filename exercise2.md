# Архитектура
## Уровни веб-приложения
Существует четыре общих уровня веб-приложений:

1. **Уровень представления (PL)** - этот уровень имеет компоненты пользовательского интерфейса, которые визуализируют и показывают данные для пользователей. Включает в себя также потенциальные взаимодействия, которые могут возникать между пользователем и веб-страницей.    
**Основная цель уровня представления**  - получить входные данные, обработать запросы пользователей, отправить их в службу данных и показать результаты.
Для построения этого уровня используются три фундаментальные технологии: HTML, CSS и JavaScript. HTML описывает ваш интерфейс, CSS стилизует его, а JS вкладывает в него жизнь (то есть управляет его поведением, когда пользователи взаимодействуют с ним). Помимо этих трех технологий, вы можете использовать любой фреймворк, который облегчит вашу разработку. Некоторые распространенные фреймворки внешнего интерфейса включают Laravel, React, NextJS, Vue, GatsbyJS и т.д.

2. **Уровень обслуживания данных (DSL)** -  этот уровень гарантирует безопасность данных, изолируя бизнес-логику со стороны клиента и передает данные, обработанные уровнем бизнес-логики, на уровень представления.     
**Основная цель уровня обслуживания данных** -  обеспечить безопасность вашей базы данных, а также данных, которые вы сохраняете после взаимодействия с клиентами. 

3. **Уровень бизнес-логики (BLL)** - это внутренняя служба, которая принимает запросы от клиента и обрабатывает их. Он управляет тем, к чему пользователь может получить доступ, и определяет, как инфраструктура используется для обслуживания пользовательских запросов.
этот уровень несет ответственность за надлежащий обмен данными, чтобы сделать их доступными для пользователя. Наличие такого уровня гарантирует, что ваша бизнес-логика не будет доступна вашему клиенту и, в конечном счете, пользователям. Изоляция бизнес-логики очень помогает в конфиденциальных операциях, таких как обработка платежей или управление медицинскими записями, процесс входа в систему, функцию онлайн-заказа, обмен сообщениями, а также другие формы взаимодействия с контентом на странице.    
**Основная цель уровня бизнес-логики** - определить логику бизнес-операций и правил.

4. **Уровень доступа к данным (DAL)** предлагает упрощенный доступ к данным, хранящимся в постоянных хранилищах, таких как двоичные файлы и файлы XML. Этот уровень также является частью типичного дизайна веб-архитектуры.     
**Основная цель уровня доступа к данным**  -  получать доступ к своим данным и управлять ими, включая выполнение таких действий, как создание, чтение, обновление и удаление сохраненных данных (CRUD).

## Что такое монолитная и микросервисная архитектуры веб-приложения? Каковы различия между монолитом и микросервисами?

**Монолитная архитектура** — это традиционная модель разработки программного обеспечения, в которой одна база кода используется для выполнения нескольких бизнес-функций. Все программные компоненты монолитной системы взаимозависимы из-за использования встроенных механизмов обмена данными внутри системы. 

**Микросервисная архитектура (или просто «микросервисы»)** -  это метод организации архитектуры, основанный на ряде независимо развертываемых служб. У этих служб есть собственная бизнес-логика и база данных с конкретной целью. Обновление, тестирование, развертывание и масштабирование выполняются внутри каждой службы. Микросервисы разбивают крупные задачи, характерные для конкретного бизнеса, на несколько независимых баз кода. Микросервисы не снижают сложность, но они делают любую сложность видимой и более управляемой, разделяя задачи на более мелкие процессы, которые функционируют независимо друг от друга и вносят вклад в общее целое.

Главное отличие микросервисов от монолита в том, что монолитные приложения обычно состоят из пользовательского интерфейса на стороне клиента, базы данных и серверного приложения. Разработчики создают все эти модули в одной базе кода. В микросервесной архитектуре каждый микросервис выполняет одну функцию или один элемент бизнес-логики. Микросервисы взаимодействуют друг с другом через API, а не через встроенные механизмы языка программирования.

**Ключевые отличия монолитной архитектуры от микросервисов** 

* _Процесс разработки_   
Начать работу проще с монолитным приложением, так как не требуется предварительное планирование. Можно создать базовый вариант и добавлять модули кода по мере необходимости. Архитектура микросервисов требует все тщательно продумать еще до того, как начинать разработку. Сначала нужно определить, какие функциональные возможности могут работать независимо друг от друга, и создать согласованный проект API. 

* _Развертывание_   
Развертывание монолитных приложений проще, чем развертывание микросервисов. Разработчики устанавливают всю базу кода и зависимости для приложения в одной среде. 
Развертывание приложений на основе микросервисов намного сложнее, поскольку каждый микросервис представляет собой независимо развертываемый пакет программного обеспечения. 

* _Отладка_   
При отладке монолитной архитектуры разработчик может отслеживать перемещение данных или изучать поведение, непосредственно анализируя кода в одной среде программирования. Для выявления проблем в коде с микросервисной архитектурой придется анализировать сразу несколько слабо связанных сервисов.

* _Модификации_   
Небольшое изменение в одной части монолитного приложения влияет на многие функции программного обеспечения, поскольку весь его код тесно связан. Кроме того, любые изменения в монолитном приложении приводят к тому, что всю систему нужно повторно тестировать и развертывать на сервере.
Подход, основанный на микросервисах, наоборот, очень гибок. Вносить изменения в такое приложение намного проще. Разработчикам не нужно модифицировать все сервисы, достаточно лишь изменить конкретные функции. Также есть возможность развертывать сервисы независимо друг от друга. 

* _Масштабирование_   
Монолитная архитектура объединяет все функциональные возможности в одной базе кода, поэтому масштабировать при изменении требований придется все приложение сразу. 
Ресурсы для любого компонента в микросервисной системе можно масштабировать независимо от других, в зависимости от текущих и прогнозируемых потребностей.

* _Ускорение внедрения инноваций_    
Монолитная архитектура мешает внедрять новые бизнес-возможности и технологии в существующие приложения. У разработчиков нет простой возможности изменить часть базы кода, используя новые технологические решения, что не позволяет организации адаптироваться к современным технологическим тенденциям.
С другой стороны, микросервисы представляют собой независимые программные компоненты, которые могут работать на основе разных платформ и технологий. Слабая взаимозависимость между микросервисами позволяет компаниям быстрее обновлять отдельные компоненты. 
Снижение рисков
Даже незначительная ошибка в базе кода может привести к остановке работы всего монолитного приложения. Такие инциденты приводят к серьезным перебоям в обслуживании и могут затронуть всех активных пользователей.
В случае сбоя микросервиса другие микросервисы продолжают работать, что ограничивает уязвимость приложения.

* _Сокращение времени вывода продуктов на рынок_    
По мере роста сложности кода в монолитных приложениях сложность разработки возрастает экспоненциально. 
И наоборот, организации с  опытом создания микросервисов могут быстрее разрабатывать и выпускать цифровые продукты. В данной архитектуре программного обеспечения каждый разработчик работает с небольшим фрагментом кода, не отвлекаясь на общую схему. При создании конкретного микросервиса не нужно даже знать, как работают другие микросервисы. Достаточно лишь правильно использовать соответствующие API, что гораздо быстрее и проще для понимания. 

* _Сокращение совокупной стоимости владения_    
Микросервисный подход более рентабелен в долгосрочной перспективе.
Микросервисные приложения легко масштабировать горизонтально, добавляя вычислительные ресурсы по мере необходимости. Чаще всего достаточно добавить ресурсы для отдельного сервиса, а не для всего приложения. Для масштабирования монолитных систем компаниям приходится увеличивать объем памяти и вычислительную мощность для всего приложения в целом, что обходится дороже. 
Помимо затрат на инфраструктуру, расходы на обслуживание монолитных приложений также растут по мере изменения требований. Например, разработчикам иногда приходится запускать старое монолитное ПО на новом оборудовании. Для этого нужно хорошо понимать требования системы, а часто еще и вносить в приложение изменения для сохранения работоспособности. Микросервисы, в свою очередь, не зависят от конкретного оборудования и платформ, что избавляет организации от больших затрат на обновление.

## Почему не все приложения построены на микросервисной архитектуре?

**Монолитная архитектура** лучше всего подходит для небольших продуктов с простой функциональностью, универсальных продуктов, предназначенных для обработки небольшого трафика (пример: веб—приложения для конвертации валют, блоги). Преимуществом этой модели является ее простота. Для создания и поддержки приложения такого типа требуется минимум ресурсов и, соответственно, небольшой бюджет. В то же время монолитная архитектура не ограничивает вас в разработке вашего продукта, поскольку этот тип архитектуры может быть преобразован в будущем, превратив его в микросервисный тип архитектуры. Скачки трафика могут быть серьезной проблемой для монолитных веб-приложений. В случаях значительного роста трафика приложение может выйти из строя из-за ограниченных возможностей его серверов. Это часто приводит к высокому показателю отказов, а также к снижению ваших позиций в SEO (поисковой оптимизации).

**Микросервисная архитектура** веб-приложения лучше всего подходит для крупномасштабных или сложных продуктов или веб-приложений, которые вы планируете масштабировать; систем, функциональность которых вы планируете регулярно обновлять; тестирования различных подходов к обслуживанию клиентов в вашем продукте (пример: социальные сети). Современная веб-архитектура должна быть максимально гибкой, чтобы вы могли легко и быстро адаптировать свой продукт к потребностям рынка и ожиданиям ваших пользователей. Более того, если вы планируете запустить международный проект, число пользователей которого может расти экспоненциально, микросервисная модель будет безопасным вариантом. Это позволяет добавлять новые компоненты в систему и исправлять любые ошибки, не отключая все.  

**_Чтобы сделать выбор между разработкой микросервисов и монолитной архитектурой, необходимо оценить следующие факторы._** 

1. **Размер приложения**   
Монолитный подход удобнее при разработке простого приложения или прототипа. Монолитные приложения используют единую кодовую базу и одну платформу, а значит разработчикам не нужно интегрировать несколько сервисов при разработке программного обеспечения. Микросервисные приложения могут потребовать значительных затрат времени и усилий на разработку, которые не оправдываются для небольших проектов. 
Но архитектура микросервисов лучше подходит для построения сложной системы. Она предоставит вашей команде надежную программную основу и позволит гибко добавлять дополнительные функции.   

2. **Компетентность команды**  
Разработка с использованием микросервисов предоставляет больше гибкости, но требует другого набора знаний и проектного мышления. В отличие от монолитных приложений, разработка микросервисов требует понимания облачной архитектуры, API, контейнеризации и других технологий, характерных для современных облачных приложений. Кроме того, устранение неполадок в микросервисах может оказаться непростой задачей для разработчиков, не имеющих опыта работы с распределенной архитектурой. 

3. **Инфраструктура**   
Монолитное приложение работает на одном сервере, а приложения микросервисов лучше используют преимущества облачной среды. Ничто не мешает запускать все микросервисы на одном сервере, но разработчики обычно предпочитают использовать несколько поставщиков облачных услуг, чтобы обеспечить масштабируемость, отказоустойчивость и высокую доступность.

## Каковы особенности тестирования монолитных и микросервисных веб-приложений?

### **Виды тестирования при разработке монолитного приложения**. 

•	**Юнит-тестирование**   
В случае монолитной архитектуры возникает проблемы с поддержанием и написанием юнит-тестов. На начальных этапах жизни приложения данное тестирование не представляет никаких трудностей, однако по мере роста кодовой базы приложения возникают проблемы с поддержкой. Из-за большой кодовой базы бывает сложно найти, разобраться и поправить определенный юнит-тест или написать новый. В результате в какой-то момент возникает ситуация, когда есть большая кодовая база, которая частично покрыта юнит-тестами, часть из которых может быть не актуализирована под новый функционал, а на часть функционала вообще нет тестов.   
•	**Авто-тестирование**     
Сталкивается с теми же проблемами, что и юнит-тестирование: сложность разработки при большой кодовой базе. Из-за обилия бизнес-логики в монолите приложения, написать и поддержать автотесты на весь функционал проблематично, так как изменение какой-либо части бизнес-логики потребует исправлений во всех автотестах, в которых использует данный кусок логики.    
•	**Интеграционное тестирование**    
Так как в монолитной архитектуре все сосредоточенно в одном сервисе, то интеграционное тестирование может сводиться к проверке поведения при работе с серверами баз данных.    
•	**Нагрузочное тестирование**  
Проблема при тестировании монолитной архитектуры сводится к большому количеству элементов, которые необходимо проверить. В определенный момент становится достаточно сложно поддержать и обеспечить необходимое качество приложения, использующего подход монолитной архитектуры

### **Виды тестирования при работе с микросервисами**.

•	**Юнит-тестирование**  
Микросервисы, в отличие от монолита, имеют меньшую кодовую базу, а это значит, что покрыть микросервис юнит-тестами и поддерживать их значительно проще.   
•	**Авто-тестирование**  
Похожая ситуация с авто-тестами. Из-за того, что микросервис содержит только часть бизнес-логики приложения, покрыть эту часть автотестами, которые будут выполняться только в рамках этого микросервиса, гораздо проще. Однако, в случае покрытия самого сервиса тестами, необходимо также убедиться, что само приложение в связке всех микросервисов работает правильно. Для этого необходимо также написать автотесты, которые повторяют основные сценарии пользователя.   
•	**Интеграционное тестирование**  
В отличие от монолитной архитектуры, важность интеграционного тестирования становится более весомой. Так как сетевое взаимодействие - единственный вид взаимодействия между микросервисами, интеграционному тестированию необходимо уделить большее внимание, чем в монолите. В тест план для интеграционного тестирования входит проверка возможности взаимодействия с другими микросервисами, а также результат этого взаимодействия. Это может взаимодействие как между Main Service и любым из трех сервисов , так и взаимодействие сервисов между собой. По результатам интеграционного тестирования можно судить о доступности микросервиса другим микросервисам.   
•	**Нагрузочное тестирование**  
Помимо возросшей важности интеграционных тестов, также возрастает необходимость в правильно составленных нагрузочных тестах. Кроме того, что микросервисы общаются с базой данных, они могут общаться между собой. А это значит, что может возникнуть ситуация, когда два микросервиса не могут нормально общаться между собой, так как большая нагрузка между ними не позволяет быстро обрабатывать запросы. В результате, помимо проверки нагрузки при общении микросервисов с базой данных возникает необходимость в проверки их общения между собой.   

Главным преимуществом и одновременно трудностью тестирования микросервисов является то, что они располагаются на различных серверах и написаны на разных языках программирования, таких как Java и .Net. Фактически разработчики определённого микросервиса не знают, что делают остальные микросервисы, что усложняет процесс тестирования.  

### Анализируя выше описанные виды тестирования, можно увидеть, что там, где возникают трудности в тестировании монолита, в тестировании микросервиса их нет, и наоборот. В связи с этим нельзя однозначно утверждать, что микросервис или монолит лучше в плане тестируемости, так как у каждого подхода свои сложности при подготовке и разработке тестов.


